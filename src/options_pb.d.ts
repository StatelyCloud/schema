// @generated by protoc-gen-es v1.10.0 with parameter "target=js+dts"
// @generated from file options.proto (package stately.schemamodel, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * TODO: Not sure if I'll regret using a single "number" enum for ints and
 * floats, but we can always fork them later.
 *
 * @generated from enum stately.schemamodel.NumberInterpretAs
 */
export declare enum NumberInterpretAs {
  /**
   * The default value is to interpret as the numeric value.
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_NUMBER = 0;
   */
  NUMBER = 0,

  /**
   * The value is a UNIX timestamp in seconds. The precision is based on the
   * original type's capacity (e.g. ints are truncated, floats are as close to
   * microseconds as possible).
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_TIMESTAMP_SECONDS = 1;
   */
  TIMESTAMP_SECONDS = 1,

  /**
   * The value is a UNIX timestamp in milliseconds. The precision is based on
   * the original type's capacity (e.g. ints are truncated, floats are as close
   * to microseconds as possible).
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_TIMESTAMP_MILLISECONDS = 2;
   */
  TIMESTAMP_MILLISECONDS = 2,

  /**
   * The value is a UNIX timestamp in microseconds. The precision is based on
   * the original type's capacity (e.g. ints are truncated, floats are as close
   * to microseconds as possible).
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_TIMESTAMP_MICROSECONDS = 3;
   */
  TIMESTAMP_MICROSECONDS = 3,

  /**
   * The value is a duration in seconds. The precision is based on the original
   * type's capacity (e.g. ints are truncated, floats are not).
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_DURATION_SECONDS = 4;
   */
  DURATION_SECONDS = 4,

  /**
   * The value is a duration in milliseconds. The precision is based on the
   * original type's capacity (e.g. ints are truncated, floats are not).
   *
   * @generated from enum value: NUMBER_INTERPRET_AS_DURATION_MILLISECONDS = 5;
   */
  DURATION_MILLISECONDS = 5,
}

/**
 * @generated from enum stately.schemamodel.BytesInterpretAs
 */
export declare enum BytesInterpretAs {
  /**
   * The default value is to interpret the bytes as a binary blob.
   *
   * @generated from enum value: BYTES_INTERPRET_AS_BYTES = 0;
   */
  BYTES = 0,

  /**
   * The bytes are a 128-bit (16 byte) UUID. The length should be validated.
   *
   * @generated from enum value: BYTES_INTERPRET_AS_UUID = 1;
   */
  UUID = 1,
}

/**
 * @generated from enum stately.schemamodel.StringInterpretAs
 */
export declare enum StringInterpretAs {
  /**
   * The default value is to interpret the string as a string.
   *
   * @generated from enum value: STRING_INTERPRET_AS_STRING = 0;
   */
  STRING = 0,

  /**
   * The string is a key path to another item. The path should be validated.
   *
   * @generated from enum value: STRING_INTERPRET_AS_KEY_PATH = 1;
   */
  KEY_PATH = 1,

  /**
   * The string is a URL. The URL should be validated.
   *
   * The string is stringified UUID. Prefer to use BYTES_INTERPRET_AS_UUID.
   * STRING_INTERPRET_AS_UUID = 3;
   * TODO: STRING_INTERPRET_AS_IP_ADDRESS? How many stringy versions of things would we actually want to support?
   *
   * @generated from enum value: STRING_INTERPRET_AS_URL = 2;
   */
  URL = 2,
}

/**
 * @generated from message stately.schemamodel.MessageOptions
 */
export declare class MessageOptions extends Message<MessageOptions> {
  /**
   * key_paths is a list of key paths that this message will be stored at. The
   * first entry in this list is required, while subsequent entries represent
   * aliased alternative paths. For example, a user might be stored at both
   * `/org-id/user-id` and `/user-id`. The first path is the primary path, and
   * the subsequent paths are "aliases" that the item can be looked up at.
   *
   * @generated from field: repeated stately.schemamodel.MessageOptions.KeyPath key_paths = 1;
   */
  keyPaths: MessageOptions_KeyPath[];

  /**
   * ttl optionally controls the TTL of the item as a whole.
   *
   * @generated from field: stately.schemamodel.Ttl ttl = 2;
   */
  ttl?: Ttl;

  /**
   * @generated from field: repeated stately.schemamodel.MessageOptions.Index indexes = 4;
   */
  indexes: MessageOptions_Index[];

  constructor(data?: PartialMessage<MessageOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.MessageOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MessageOptions;

  static equals(
    a: MessageOptions | PlainMessage<MessageOptions> | undefined,
    b: MessageOptions | PlainMessage<MessageOptions> | undefined,
  ): boolean;
}

/**
 * @generated from message stately.schemamodel.MessageOptions.KeyPath
 */
export declare class MessageOptions_KeyPath extends Message<MessageOptions_KeyPath> {
  /**
   * path_template is a url pattern that will be used to generate the path for
   * this key. The template should be a valid URL Pattern as defined in
   * https://urlpattern.spec.whatwg.org/ (see also
   * https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API and
   * https://github.com/soongo/path-to-regexp). It should also be a valid
   * Stately key path when all variables are substituted into it. Each variable
   * should correspond to the name or field ID of a field in the parent message,
   * and each of those fields should be a number, string, or binary type.
   *
   * For example, a `User` message with fields `user_id` and `org_id` could have
   * a key path template of `/orgs-:org_id/users-:user_id`.
   *
   * @generated from field: string path_template = 1;
   */
  pathTemplate: string;

  constructor(data?: PartialMessage<MessageOptions_KeyPath>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.MessageOptions.KeyPath";
  static readonly fields: FieldList;

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): MessageOptions_KeyPath;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageOptions_KeyPath;

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): MessageOptions_KeyPath;

  static equals(
    a: MessageOptions_KeyPath | PlainMessage<MessageOptions_KeyPath> | undefined,
    b: MessageOptions_KeyPath | PlainMessage<MessageOptions_KeyPath> | undefined,
  ): boolean;
}

/**
 * Index configures how we should build indexes based on the fields of the
 * item. Today this can only configure LSIs but could be extended to configure
 * other indexes, or we could use another structure for that.
 *
 * @generated from message stately.schemamodel.MessageOptions.Index
 */
export declare class MessageOptions_Index extends Message<MessageOptions_Index> {
  /**
   * property_path is the path to the field that should be indexed. This is a
   * required field, and should be a valid path to a field in the message in
   * property path syntax.
   *
   * @generated from field: string property_path = 1;
   */
  propertyPath: string;

  /**
   * group_local_index optionally chooses a group-local index (LSI) that should be
   * populated with this field's value. We support up to 4 group-local indexed
   * fields per message.
   *
   * @generated from field: uint32 group_local_index = 2;
   */
  groupLocalIndex: number;

  constructor(data?: PartialMessage<MessageOptions_Index>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.MessageOptions.Index";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageOptions_Index;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageOptions_Index;

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): MessageOptions_Index;

  static equals(
    a: MessageOptions_Index | PlainMessage<MessageOptions_Index> | undefined,
    b: MessageOptions_Index | PlainMessage<MessageOptions_Index> | undefined,
  ): boolean;
}

/**
 * @generated from message stately.schemamodel.Ttl
 */
export declare class Ttl extends Message<Ttl> {
  /**
   * @generated from oneof stately.schemamodel.Ttl.value
   */
  value:
    | {
        /**
         * duration_seconds sets the offset for the TTL source. For example, if the
         * source is FROM_CREATED, and offset_duration_s is 15, then the item
         * will expire 15s after it was created.
         *
         * @generated from field: uint64 duration_seconds = 1;
         */
        value: bigint;
        case: "durationSeconds";
      }
    | {
        /**
         * field sets a field to control the TTL, in property path syntax. For
         * example, if the source is FROM_CREATED, and ttl_field is "lifetime", and
         * "lifetime" is a field that holds a duration in seconds, then the item
         * will expire "lifetime" seconds after the item was created.
         *
         * @generated from field: string field = 2;
         */
        value: string;
        case: "field";
      }
    | { case: undefined; value?: undefined };

  /**
   * ttl_source explains how the value should be used to calculate the item TTL.
   *
   * @generated from field: stately.schemamodel.Ttl.TtlSource source = 3;
   */
  source: Ttl_TtlSource;

  constructor(data?: PartialMessage<Ttl>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.Ttl";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ttl;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ttl;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ttl;

  static equals(
    a: Ttl | PlainMessage<Ttl> | undefined,
    b: Ttl | PlainMessage<Ttl> | undefined,
  ): boolean;
}

/**
 * TtlSource is an enum that specifies how the TTL of an item should be
 * calculated based on the value of a field.
 *
 * @generated from enum stately.schemamodel.Ttl.TtlSource
 */
export declare enum Ttl_TtlSource {
  /**
   * The default value is no TTL. The item will not automatically expire. This
   * shouldn't actually be used - instead, ttl should not be set on the
   * message.
   *
   * @generated from enum value: TTL_SOURCE_UNSET = 0;
   */
  UNSET = 0,

  /**
   * Set the TTL of the item to the value in seconds from the time the
   * item was created.
   *
   * @generated from enum value: TTL_SOURCE_FROM_CREATED = 1;
   */
  FROM_CREATED = 1,

  /**
   * Set the TTL of the item to the value in seconds from the time the
   * item was last modified. This expiry is pushed out every time the item is
   * modified.
   *
   * @generated from enum value: TTL_SOURCE_FROM_LAST_MODIFIED = 2;
   */
  FROM_LAST_MODIFIED = 2,

  /**
   * Set the TTL of the item to the value as an absolute UNIX
   * timestamp.
   *
   * @generated from enum value: TTL_SOURCE_AT_TIMESTAMP = 3;
   */
  AT_TIMESTAMP = 3,
}

/**
 * @generated from message stately.schemamodel.FieldOptions
 */
export declare class FieldOptions extends Message<FieldOptions> {
  /**
   * @generated from oneof stately.schemamodel.FieldOptions.type
   */
  type:
    | {
        /**
         * Scalar Field Types
         *
         * @generated from field: stately.schemamodel.FloatOptions float = 1;
         */
        value: FloatOptions;
        case: "float";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.DoubleOptions double = 2;
         */
        value: DoubleOptions;
        case: "double";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Int32Options int32 = 3;
         */
        value: Int32Options;
        case: "int32";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Int64Options int64 = 4;
         */
        value: Int64Options;
        case: "int64";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.UInt32Options uint32 = 5;
         */
        value: UInt32Options;
        case: "uint32";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.UInt64Options uint64 = 6;
         */
        value: UInt64Options;
        case: "uint64";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.SInt32Options sint32 = 7;
         */
        value: SInt32Options;
        case: "sint32";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.SInt64Options sint64 = 8;
         */
        value: SInt64Options;
        case: "sint64";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Fixed32Options fixed32 = 9;
         */
        value: Fixed32Options;
        case: "fixed32";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Fixed64Options fixed64 = 10;
         */
        value: Fixed64Options;
        case: "fixed64";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.SFixed32Options sfixed32 = 11;
         */
        value: SFixed32Options;
        case: "sfixed32";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.SFixed64Options sfixed64 = 12;
         */
        value: SFixed64Options;
        case: "sfixed64";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.BoolOptions bool = 13;
         */
        value: BoolOptions;
        case: "bool";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.StringOptions string = 14;
         */
        value: StringOptions;
        case: "string";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.BytesOptions bytes = 15;
         */
        value: BytesOptions;
        case: "bytes";
      }
    | { case: undefined; value?: undefined };

  /**
   * @generated from oneof stately.schemamodel.FieldOptions.value
   */
  value:
    | {
        /**
         * initial_value optionally chooses where the initial value for a field
         * comes from if it is not provided at creation. The field behaves normally
         * after its default is populated. Not all values are valid for all types -
         * I guess we could have only the valid options defined in each type option
         * message, but that feels unnecessary.
         *
         * @generated from field: stately.schemamodel.FieldOptions.InitialValue initial_value = 24;
         */
        value: FieldOptions_InitialValue;
        case: "initialValue";
      }
    | {
        /**
         * from_metadata optionally chooses which metadata field to reflect into
         * this field. This implicitly makes the field read-only. Any value
         * specified in this field by customers is ignored, as it will be populated
         * by the system.
         *
         * @generated from field: stately.schemamodel.FieldOptions.FromMetadata from_metadata = 25;
         */
        value: FieldOptions_FromMetadata;
        case: "fromMetadata";
      }
    | {
        /**
         * cel_expression optionally sets this field to be computed by a CEL
         * expression based on other fields in the item. This allows for computed or
         * "virtual" fields. This implies that the field cannot be set by the client
         * and is readonly. Its value should not be stored. Any value specified in
         * this field by customers is ignored, as it will be populated by the
         * system.
         *
         * @generated from field: string cel_expression = 26;
         */
        value: string;
        case: "celExpression";
      }
    | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FieldOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.FieldOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldOptions;

  static equals(
    a: FieldOptions | PlainMessage<FieldOptions> | undefined,
    b: FieldOptions | PlainMessage<FieldOptions> | undefined,
  ): boolean;
}

/**
 * @generated from enum stately.schemamodel.FieldOptions.FromMetadata
 */
export declare enum FieldOptions_FromMetadata {
  /**
   * @generated from enum value: FROM_METADATA_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Populate this field with the timestamp when the item was first created.
   *
   * @generated from enum value: FROM_METADATA_CREATED_AT_TIME = 1;
   */
  CREATED_AT_TIME = 1,

  /**
   * Populate this field with the timestamp when the item was most recently modified.
   *
   * @generated from enum value: FROM_METADATA_LAST_MODIFIED_AT_TIME = 2;
   */
  LAST_MODIFIED_AT_TIME = 2,

  /**
   * Populate this field with the group version when the item was first created.
   *
   * @generated from enum value: FROM_METADATA_CREATED_AT_VERSION = 3;
   */
  CREATED_AT_VERSION = 3,

  /**
   * Populate this field with the group version when the item was most recently modified.
   *
   * @generated from enum value: FROM_METADATA_LAST_MODIFIED_AT_VERSION = 4;
   */
  LAST_MODIFIED_AT_VERSION = 4,

  /**
   * Populate this field with the number of times the item has been updated.
   *
   * @generated from enum value: FROM_METADATA_UPDATE_COUNT = 5;
   */
  UPDATE_COUNT = 5,

  /**
   * Populate this field with the full key path to the item.
   *
   * @generated from enum value: FROM_METADATA_KEY_PATH = 6;
   */
  KEY_PATH = 6,
}

/**
 * InitialValue specifies where the initial value for a field should come from
 * if it is not explicitly set when created. All of these values would be
 * assigned by the server at creation time.
 *
 * @generated from enum stately.schemamodel.FieldOptions.InitialValue
 */
export declare enum FieldOptions_InitialValue {
  /**
   * @generated from enum value: INITIAL_VALUE_NONE = 0;
   */
  NONE = 0,

  /**
   * SEQUENCE will assign the field a monotonically increasing, contiguous ID
   * that is unique *within the parent path and item type*. This is only valid
   * for a numeric ID field of a non-root item.
   *
   * @generated from enum value: INITIAL_VALUE_SEQUENCE = 1;
   */
  SEQUENCE = 1,

  /**
   * UUID will assign the field a globally unique, random 128-bit UUIDv4. This
   * will be encoded in the item key path as a binary ID. This is usable
   * anywhere, in any store config. This is only valid for bytes types.
   *
   * @generated from enum value: INITIAL_VALUE_UUID = 2;
   */
  UUID = 2,

  /**
   * RAND53 will assign the field a random 53-bit numeric ID that is unique
   * *within the parent path and item type*, but is not globally unique. This is
   * usable anywhere, in any store config. We use 53 bits instead of 64 because
   * 53 bits is still a lot of bits, and it's the largest integer that can be
   * represented exactly in JavaScript. This is only valid for a numeric ID
   * field of a non-root item.
   *
   * @generated from enum value: INITIAL_VALUE_RAND53 = 4;
   */
  RAND53 = 4,
}

/**
 * The following are options that differ based on the underlying type of the field.
 *
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * float default = 1;
 *
 * @generated from message stately.schemamodel.FloatOptions
 */
export declare class FloatOptions extends Message<FloatOptions> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<FloatOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.FloatOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatOptions;

  static equals(
    a: FloatOptions | PlainMessage<FloatOptions> | undefined,
    b: FloatOptions | PlainMessage<FloatOptions> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * double default = 1;
 *
 * @generated from message stately.schemamodel.DoubleOptions
 */
export declare class DoubleOptions extends Message<DoubleOptions> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<DoubleOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.DoubleOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleOptions;

  static equals(
    a: DoubleOptions | PlainMessage<DoubleOptions> | undefined,
    b: DoubleOptions | PlainMessage<DoubleOptions> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * int32 default = 1;
 *
 * @generated from message stately.schemamodel.Int32Options
 */
export declare class Int32Options extends Message<Int32Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<Int32Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.Int32Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Options;

  static equals(
    a: Int32Options | PlainMessage<Int32Options> | undefined,
    b: Int32Options | PlainMessage<Int32Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * int64 default = 1;
 *
 * @generated from message stately.schemamodel.Int64Options
 */
export declare class Int64Options extends Message<Int64Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<Int64Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.Int64Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Options;

  static equals(
    a: Int64Options | PlainMessage<Int64Options> | undefined,
    b: Int64Options | PlainMessage<Int64Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * uint32 default = 1;
 *
 * @generated from message stately.schemamodel.UInt32Options
 */
export declare class UInt32Options extends Message<UInt32Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<UInt32Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.UInt32Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Options;

  static equals(
    a: UInt32Options | PlainMessage<UInt32Options> | undefined,
    b: UInt32Options | PlainMessage<UInt32Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * uint64 default = 1;
 *
 * @generated from message stately.schemamodel.UInt64Options
 */
export declare class UInt64Options extends Message<UInt64Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<UInt64Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.UInt64Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Options;

  static equals(
    a: UInt64Options | PlainMessage<UInt64Options> | undefined,
    b: UInt64Options | PlainMessage<UInt64Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * sint32 default = 1;
 *
 * @generated from message stately.schemamodel.SInt32Options
 */
export declare class SInt32Options extends Message<SInt32Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<SInt32Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.SInt32Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt32Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt32Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt32Options;

  static equals(
    a: SInt32Options | PlainMessage<SInt32Options> | undefined,
    b: SInt32Options | PlainMessage<SInt32Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * sint64 default = 1;
 *
 * @generated from message stately.schemamodel.SInt64Options
 */
export declare class SInt64Options extends Message<SInt64Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<SInt64Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.SInt64Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SInt64Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SInt64Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SInt64Options;

  static equals(
    a: SInt64Options | PlainMessage<SInt64Options> | undefined,
    b: SInt64Options | PlainMessage<SInt64Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * fixed32 default = 1;
 *
 * @generated from message stately.schemamodel.Fixed32Options
 */
export declare class Fixed32Options extends Message<Fixed32Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<Fixed32Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.Fixed32Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed32Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed32Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed32Options;

  static equals(
    a: Fixed32Options | PlainMessage<Fixed32Options> | undefined,
    b: Fixed32Options | PlainMessage<Fixed32Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * fixed64 default = 1;
 *
 * @generated from message stately.schemamodel.Fixed64Options
 */
export declare class Fixed64Options extends Message<Fixed64Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<Fixed64Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.Fixed64Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed64Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed64Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed64Options;

  static equals(
    a: Fixed64Options | PlainMessage<Fixed64Options> | undefined,
    b: Fixed64Options | PlainMessage<Fixed64Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * sfixed32 default = 1;
 *
 * @generated from message stately.schemamodel.SFixed32Options
 */
export declare class SFixed32Options extends Message<SFixed32Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<SFixed32Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.SFixed32Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed32Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed32Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed32Options;

  static equals(
    a: SFixed32Options | PlainMessage<SFixed32Options> | undefined,
    b: SFixed32Options | PlainMessage<SFixed32Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * sfixed64 default = 1;
 *
 * @generated from message stately.schemamodel.SFixed64Options
 */
export declare class SFixed64Options extends Message<SFixed64Options> {
  /**
   * interpret_as optionally chooses how to interpret the value in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;

  constructor(data?: PartialMessage<SFixed64Options>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.SFixed64Options";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFixed64Options;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFixed64Options;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFixed64Options;

  static equals(
    a: SFixed64Options | PlainMessage<SFixed64Options> | undefined,
    b: SFixed64Options | PlainMessage<SFixed64Options> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be 0, but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * bool default = 1;
 *
 * @generated from message stately.schemamodel.BoolOptions
 */
export declare class BoolOptions extends Message<BoolOptions> {
  constructor(data?: PartialMessage<BoolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.BoolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolOptions;

  static equals(
    a: BoolOptions | PlainMessage<BoolOptions> | undefined,
    b: BoolOptions | PlainMessage<BoolOptions> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be "", but if this is set, it will be used
 * instead when the field is unset. Setting this option implies the "optional"
 * (or field_presence.explicit) field option is also set to true, since
 * otherwise you could not distinguish between the field being unset and the
 * field being set to the default value.
 * string default = 1;
 *
 * @generated from message stately.schemamodel.StringOptions
 */
export declare class StringOptions extends Message<StringOptions> {
  /**
   * interpret_as optionally chooses how to interpret the string in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.StringInterpretAs interpret_as = 2;
   */
  interpretAs: StringInterpretAs;

  constructor(data?: PartialMessage<StringOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.StringOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringOptions;

  static equals(
    a: StringOptions | PlainMessage<StringOptions> | undefined,
    b: StringOptions | PlainMessage<StringOptions> | undefined,
  ): boolean;
}

/**
 * default sets the default value for this field. Usually a proto field's
 * default (unset) value would be an empty byte string, but if this is set, it
 * will be used instead when the field is unset. Setting this option implies
 * the "optional" (or field_presence.explicit) field option is also set to
 * true, since otherwise you could not distinguish between the field being
 * unset and the field being set to the default value.
 * bytes default = 1;
 *
 * @generated from message stately.schemamodel.BytesOptions
 */
export declare class BytesOptions extends Message<BytesOptions> {
  /**
   * interpret_as optionally chooses how to interpret the bytes in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.BytesInterpretAs interpret_as = 2;
   */
  interpretAs: BytesInterpretAs;

  constructor(data?: PartialMessage<BytesOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "stately.schemamodel.BytesOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BytesOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BytesOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BytesOptions;

  static equals(
    a: BytesOptions | PlainMessage<BytesOptions> | undefined,
    b: BytesOptions | PlainMessage<BytesOptions> | undefined,
  ): boolean;
}
