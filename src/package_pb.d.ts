// @generated by protoc-gen-es v2.2.3 with parameter "target=js+dts,import_extension=.js"
// @generated from file package.proto (package stately.schemamodel, syntax proto3)
/* eslint-disable */

import type { Message } from "@bufbuild/protobuf";
import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type {
  BytesInterpretAs,
  InitialValue,
  MessageOptions,
  NumberInterpretAs,
  StringInterpretAs,
} from "./options_pb.js";

/**
 * Describes the file package.proto.
 */
export declare const file_package: GenFile;

/**
 * A SchemaPackage is a collection of schema items, etc.
 *
 * @generated from message stately.schemamodel.SchemaPackage
 */
export declare type SchemaPackage = Message<"stately.schemamodel.SchemaPackage"> & {
  /**
   * package_name is the proto-package name for the schema.
   * This is a left-over from proto semantics, that may not be required in all languages
   * given the way we generate code.
   * When this is empty, we will automatically generate a package name "s" for a storage
   * schema, and `stately.generated` for wire schema.
   *
   * @generated from field: string package_name = 1;
   */
  packageName: string;

  /**
   * file_name is the name of the "proto file" that this schema package was generated from.
   * This is a left-over from proto semantics, that may not be required in all languages
   * given the way we generate code.
   * When empty, this will be set to "schema.proto".
   *
   * @generated from field: string file_name = 2;
   */
  fileName: string;

  /**
   * messages are ItemTypes or ObjectTypes defined in schema.
   *
   * @generated from field: repeated stately.schemamodel.MessageType messages = 3;
   */
  messages: MessageType[];

  /**
   * enums are EnumTypes defined in schema.
   *
   * @generated from field: repeated stately.schemamodel.EnumType enums = 4;
   */
  enums: EnumType[];

  /**
   * type_aliases are TypeAliases defined in schema.
   *
   * @generated from field: repeated stately.schemamodel.TypeAlias type_aliases = 5;
   */
  typeAliases: TypeAlias[];
};

/**
 * Describes the message stately.schemamodel.SchemaPackage.
 * Use `create(SchemaPackageSchema)` to create a new message.
 */
export declare const SchemaPackageSchema: GenMessage<SchemaPackage>;

/**
 * A MessageType represents either an ItemType or an ObjectType defined in schema.
 *
 * @generated from message stately.schemamodel.MessageType
 */
export declare type MessageType = Message<"stately.schemamodel.MessageType"> & {
  /**
   * type_name is the human-readable name of the underlying type. Unlike file descriptors,
   * this type name does _not_ include a package prefix.
   * When a wire model is generated in the DSL, this name *must* be present
   *
   * @generated from field: string type_name = 1;
   */
  typeName: string;

  /**
   * type_storage_id is the unique identifier for the underlying type that is used in
   * the storage model.
   * This will be absent for a schema definition generated by the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire and storage schema definitions.
   *
   * @generated from field: uint32 type_storage_id = 2;
   */
  typeStorageId: number;

  /**
   * comments are per-line comments parsed from source code.
   *
   * @generated from field: repeated string comments = 3;
   */
  comments: string[];

  /**
   * A set of validation constraints that must all be true for the message to be valid.
   *
   * @generated from field: repeated stately.schemamodel.ValidationConstraints constraints = 4;
   */
  constraints: ValidationConstraints[];

  /**
   * The fields of this object.
   *
   * @generated from field: repeated stately.schemamodel.Field fields = 5;
   */
  fields: Field[];

  /**
   * MessageOptions are the options for this message.
   *
   * @generated from field: stately.schemamodel.MessageOptions item_type_options = 6;
   */
  itemTypeOptions?: MessageOptions;
};

/**
 * Describes the message stately.schemamodel.MessageType.
 * Use `create(MessageTypeSchema)` to create a new message.
 */
export declare const MessageTypeSchema: GenMessage<MessageType>;

/**
 * @generated from message stately.schemamodel.EnumType
 */
export declare type EnumType = Message<"stately.schemamodel.EnumType"> & {
  /**
   * type_name is the human-readable name of the EnumType.
   * Unlike file descriptors, this type name does _not_ include a package prefix.
   * When a wire model is generated in the DSL, this name *must* be present.
   * This will be omitted from persisted storage schema as a space optimization.
   *
   * @generated from field: string type_name = 1;
   */
  typeName: string;

  /**
   * type_storage_id is the unique identifier for the EnumType that is used in the storage model.
   * This will be absent for a schema definition generated by the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire and storage schema definitions.
   *
   * @generated from field: uint32 type_storage_id = 2;
   */
  typeStorageId: number;

  /**
   * comments are per-line comments parsed from source code.
   *
   * @generated from field: repeated string comments = 4;
   */
  comments: string[];

  /**
   * The values this enum can take!
   *
   * @generated from field: repeated stately.schemamodel.EnumValue values = 3;
   */
  values: EnumValue[];
};

/**
 * Describes the message stately.schemamodel.EnumType.
 * Use `create(EnumTypeSchema)` to create a new message.
 */
export declare const EnumTypeSchema: GenMessage<EnumType>;

/**
 * TypeAlias are used to define a new type that is an alias for an existing type.
 *
 * @generated from message stately.schemamodel.TypeAlias
 */
export declare type TypeAlias = Message<"stately.schemamodel.TypeAlias"> & {
  /**
   * The name of the alias type.
   *
   * @generated from field: string alias_name = 1;
   */
  aliasName: string;

  /**
   * type_storage_id is the unique identifier for the underlying type alias. While this
   * isn't actually used in the storage model, it is tracked and used to optimize
   * the size of the package schema at rest and in transit.
   * This will be absent for a schema definition generated by the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire and storage schema definitions.
   *
   * @generated from field: uint32 type_storage_id = 2;
   */
  typeStorageId: number;

  /**
   * underlying_type is the type that the alias is for.
   *
   * @generated from field: stately.schemamodel.Type underlying_type = 3;
   */
  underlyingType?: Type;

  /**
   * comments are per-line comments parsed from source code that are associated with this type alias.
   *
   * @generated from field: repeated string comments = 4;
   */
  comments: string[];

  /**
   * A set of validation constraints that must all be true for the type alias to be valid.
   *
   * @generated from field: repeated stately.schemamodel.ValidationConstraints constraints = 5;
   */
  constraints: ValidationConstraints[];
};

/**
 * Describes the message stately.schemamodel.TypeAlias.
 * Use `create(TypeAliasSchema)` to create a new message.
 */
export declare const TypeAliasSchema: GenMessage<TypeAlias>;

/**
 * @generated from message stately.schemamodel.Field
 */
export declare type Field = Message<"stately.schemamodel.Field"> & {
  /**
   * field_name is the human-readable name of the field.
   * This *must* be present for all fields generated by the DSL.
   * This will be omitted when persisting the storage schema as a space optimization.
   *
   * @generated from field: string field_name = 1;
   */
  fieldName: string;

  /**
   * field_wire_number is the proto field number used by the wire model.
   * This will be absent when the wire model is generated in the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire schema definition.
   * This will also be omitted in the storage model.
   * This will be omitted when persisting the storage schema which is independent of wire
   * schema, as well as for space optimization.
   *
   * @generated from field: uint32 field_wire_number = 3;
   */
  fieldWireNumber: number;

  /**
   * field_storage_number is the field number used by the storage model.
   * This will be zero for a schema definition generated by the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire and storage schema definitions.
   *
   * @generated from field: uint32 field_storage_number = 2;
   */
  fieldStorageNumber: number;

  /**
   * comments are per-line comments parsed from source code.
   *
   * @generated from field: repeated string comments = 4;
   */
  comments: string[];

  /**
   * require_non_zero is a flag that indicates that the field must be non-zero.
   *
   * @generated from field: bool require_non_zero = 5;
   */
  requireNonZero: boolean;

  /**
   * A set of validation constraints that must all be true for the type alias to be valid.
   *
   * @generated from field: repeated stately.schemamodel.ValidationConstraints constraints = 6;
   */
  constraints: ValidationConstraints[];

  /**
   * field_type is the type of the field.
   *
   * @generated from field: stately.schemamodel.Type field_type = 7;
   */
  fieldType?: Type;

  /**
   * The read_default specifies a read-materialized default for this field
   * if it is not set. This is most useful when adding a new required field,
   * since previously-stored items will not have this field set. However, you
   * can also set a default for non-required fields. These defaults will be used
   * when the item is read.
   *
   * Note that this isn't validated as a "required" field because commonly the
   * default value will be the zero value for the field type, which is
   * represented as an empty string.
   *
   * read_default's value depends on the underlying field type.
   * * ObjectTypes is a JSON document that can be deserialized into the type of the field
   *   using ProtoJSON rules: https://protobuf.dev/programming-guides/json/.
   * * Durations can be either the golang format of "300ms", "-1.5h" or "2h45m"
   *   or a number.
   * * Timestamps can either be the RFC3339 format or a number.
   * * Enum Values can be the string name of the enum value or ordinal.
   * * For strings, it is the string value.
   * * For all other numbers, it is the number value.
   * * Bytes can either be the base64-encoded string or UUID string if the field
   *   is interpreted as a UUID.
   *
   * Keep in mind that some of the types might not exactly line up - for
   * example, ProtoJSON might specify that an int64 must always be a string, but
   * this JSON might contain a number instead if it happens to fit in the JSON
   * number range.
   *
   * @generated from field: string read_default = 8;
   */
  readDefault: string;
};

/**
 * Describes the message stately.schemamodel.Field.
 * Use `create(FieldSchema)` to create a new message.
 */
export declare const FieldSchema: GenMessage<Field>;

/**
 * @generated from message stately.schemamodel.EnumValue
 */
export declare type EnumValue = Message<"stately.schemamodel.EnumValue"> & {
  /**
   * value_name is the human-readable name of the enum value.
   * This *must* be present for all fields generated by the DSL.
   * This will be omitted when persisting the storage schema as a space optimization.
   *
   * @generated from field: string value_name = 1;
   */
  valueName: string;

  /**
   * value_wire_ordinal is enum ordinal defined in the wire model.
   * This will be omitted when persisting the storage schema as a space optimization.
   *
   * @generated from field: optional int32 value_wire_ordinal = 2;
   */
  valueWireOrdinal?: number;

  /**
   * value_storage_number is the enum ordinal defined in the storage model.
   * This will be zero for a schema definition generated by the DSL, but will be populated
   * by the schema.Package parser and persisted with the wire and storage schema definitions.
   *
   * @generated from field: optional int32 value_storage_number = 3;
   */
  valueStorageNumber?: number;

  /**
   * comments are per-line comments parsed from source code.
   *
   * @generated from field: repeated string comments = 4;
   */
  comments: string[];
};

/**
 * Describes the message stately.schemamodel.EnumValue.
 * Use `create(EnumValueSchema)` to create a new message.
 */
export declare const EnumValueSchema: GenMessage<EnumValue>;

/**
 * Type is a union of all possible types that a field can assume.
 *
 * @generated from message stately.schemamodel.Type
 */
export declare type Type = Message<"stately.schemamodel.Type"> & {
  /**
   * @generated from oneof stately.schemamodel.Type.type
   */
  type:
    | {
        /**
         * @generated from field: stately.schemamodel.Number number = 1;
         */
        value: Number;
        case: "number";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Bool bool = 2;
         */
        value: Bool;
        case: "bool";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.String string = 3;
         */
        value: String;
        case: "string";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.Binary binary = 4;
         */
        value: Binary;
        case: "binary";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.TypeRef type_ref = 5;
         */
        value: TypeRef;
        case: "typeRef";
      }
    | {
        /**
         * @generated from field: stately.schemamodel.List list = 6;
         */
        value: List;
        case: "list";
      }
    | { case: undefined; value?: undefined };
};

/**
 * Describes the message stately.schemamodel.Type.
 * Use `create(TypeSchema)` to create a new message.
 */
export declare const TypeSchema: GenMessage<Type>;

/**
 * A TypeRef is a reference to a defined type e.g. ItemType, ObjectType, EnumType, or TypeAlias,
 * which is referenced in the context of a field.
 *
 * @generated from message stately.schemamodel.TypeRef
 */
export declare type TypeRef = Message<"stately.schemamodel.TypeRef"> & {
  /**
   * ref is the reference to the defined type. This will be a string if supplied by the DSL,
   * but may be converted to a storage_id after the initial schema parsing.
   *
   * @generated from oneof stately.schemamodel.TypeRef.ref
   */
  ref:
    | {
        /**
         * @generated from field: string name = 1;
         */
        value: string;
        case: "name";
      }
    | {
        /**
         * @generated from field: uint32 storage_id = 2;
         */
        value: number;
        case: "storageId";
      }
    | { case: undefined; value?: undefined };
};

/**
 * Describes the message stately.schemamodel.TypeRef.
 * Use `create(TypeRefSchema)` to create a new message.
 */
export declare const TypeRefSchema: GenMessage<TypeRef>;

/**
 * List represents a repeated type of a field.
 *
 * @generated from message stately.schemamodel.List
 */
export declare type List = Message<"stately.schemamodel.List"> & {
  /**
   * underlying_type is the type of the elements in the list.
   *
   * @generated from field: stately.schemamodel.Type underlying_type = 1;
   */
  underlyingType?: Type;
};

/**
 * Describes the message stately.schemamodel.List.
 * Use `create(ListSchema)` to create a new message.
 */
export declare const ListSchema: GenMessage<List>;

/**
 * A Bool proto kind.
 *
 * @generated from message stately.schemamodel.Bool
 */
export declare type Bool = Message<"stately.schemamodel.Bool"> & {};

/**
 * Describes the message stately.schemamodel.Bool.
 * Use `create(BoolSchema)` to create a new message.
 */
export declare const BoolSchema: GenMessage<Bool>;

/**
 * A String proto kind.
 *
 * @generated from message stately.schemamodel.String
 */
export declare type String = Message<"stately.schemamodel.String"> & {
  /**
   * interpret_as optionally chooses how to interpret the string in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.StringInterpretAs interpret_as = 1;
   */
  interpretAs: StringInterpretAs;
};

/**
 * Describes the message stately.schemamodel.String.
 * Use `create(StringSchema)` to create a new message.
 */
export declare const StringSchema: GenMessage<String>;

/**
 * @generated from message stately.schemamodel.Binary
 */
export declare type Binary = Message<"stately.schemamodel.Binary"> & {
  /**
   * interpret_as optionally chooses how to interpret the bytes in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.BytesInterpretAs interpret_as = 1;
   */
  interpretAs: BytesInterpretAs;

  /**
   * @generated from field: stately.schemamodel.InitialValue initial_value = 2;
   */
  initialValue: InitialValue;
};

/**
 * Describes the message stately.schemamodel.Binary.
 * Use `create(BinarySchema)` to create a new message.
 */
export declare const BinarySchema: GenMessage<Binary>;

/**
 * @generated from message stately.schemamodel.Number
 */
export declare type Number = Message<"stately.schemamodel.Number"> & {
  /**
   * Any underlying proto-kind this number is.
   *
   * @generated from field: stately.schemamodel.NumberKind kind = 1;
   */
  kind: NumberKind;

  /**
   * interpret_as optionally chooses how to interpret the number in this field,
   * which can affect how they are exposed via generated SDK code.
   *
   * @generated from field: stately.schemamodel.NumberInterpretAs interpret_as = 2;
   */
  interpretAs: NumberInterpretAs;
};

/**
 * Describes the message stately.schemamodel.Number.
 * Use `create(NumberSchema)` to create a new message.
 */
export declare const NumberSchema: GenMessage<Number>;

/**
 * @generated from message stately.schemamodel.ValidationConstraints
 */
export declare type ValidationConstraints = Message<"stately.schemamodel.ValidationConstraints"> & {
  /**
   * cel_expression is the CEL expression that must evaluate to true for the message to be valid.
   *
   * @generated from field: string cel_expression = 1;
   */
  celExpression: string;

  /**
   * message is an optional message to display when the expression is false.
   * This exists for is support of https://app.clickup.com/t/8688wpvhx
   *
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message stately.schemamodel.ValidationConstraints.
 * Use `create(ValidationConstraintsSchema)` to create a new message.
 */
export declare const ValidationConstraintsSchema: GenMessage<ValidationConstraints>;

/**
 * NumberKind is the set of all possible proto number kinds.
 * The enum ordinals match 1:1 with proto kinds.
 *
 * @generated from enum stately.schemamodel.NumberKind
 */
export enum NumberKind {
  /**
   * @generated from enum value: INVALID_NUMBER_KIND = 0;
   */
  INVALID_NUMBER_KIND = 0,

  /**
   * @generated from enum value: DOUBLE_KIND = 1;
   */
  DOUBLE_KIND = 1,

  /**
   * @generated from enum value: FLOAT_KIND = 2;
   */
  FLOAT_KIND = 2,

  /**
   * @generated from enum value: INT64_KIND = 3;
   */
  INT64_KIND = 3,

  /**
   * @generated from enum value: UINT64_KIND = 4;
   */
  UINT64_KIND = 4,

  /**
   * @generated from enum value: INT32_KIND = 5;
   */
  INT32_KIND = 5,

  /**
   * @generated from enum value: FIXED64_KIND = 6;
   */
  FIXED64_KIND = 6,

  /**
   * @generated from enum value: FIXED32_KIND = 7;
   */
  FIXED32_KIND = 7,

  /**
   * @generated from enum value: UINT32_KIND = 13;
   */
  UINT32_KIND = 13,

  /**
   * @generated from enum value: SFIXED32_KIND = 15;
   */
  SFIXED32_KIND = 15,

  /**
   * @generated from enum value: SFIXED64_KIND = 16;
   */
  SFIXED64_KIND = 16,

  /**
   * @generated from enum value: SINT32_KIND = 17;
   */
  SINT32_KIND = 17,

  /**
   * @generated from enum value: SINT64_KIND = 18;
   */
  SINT64_KIND = 18,
}

/**
 * Describes the enum stately.schemamodel.NumberKind.
 */
export declare const NumberKindSchema: GenEnum<NumberKind>;
